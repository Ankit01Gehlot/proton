// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TOPICMETADATA_NLOG_H_
#define FLATBUFFERS_GENERATED_TOPICMETADATA_NLOG_H_

#include "flatbuffers/flatbuffers.h"

namespace nlog {

struct TopicMetadata;
struct TopicMetadataBuilder;

struct TopicMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopicMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_CREATE_TIMESTAMP = 6,
    VT_LAST_MODIFY_TIMESTAMP = 8,
    VT_NS = 10,
    VT_NAME = 12,
    VT_ID = 14,
    VT_PARTITIONS = 16,
    VT_REPLICAS = 18,
    VT_COMPACTED = 20
  };
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 0);
  }
  bool mutate_version(int32_t _version) {
    return SetField<int32_t>(VT_VERSION, _version, 0);
  }
  int64_t create_timestamp() const {
    return GetField<int64_t>(VT_CREATE_TIMESTAMP, 0);
  }
  bool mutate_create_timestamp(int64_t _create_timestamp) {
    return SetField<int64_t>(VT_CREATE_TIMESTAMP, _create_timestamp, 0);
  }
  int64_t last_modify_timestamp() const {
    return GetField<int64_t>(VT_LAST_MODIFY_TIMESTAMP, 0);
  }
  bool mutate_last_modify_timestamp(int64_t _last_modify_timestamp) {
    return SetField<int64_t>(VT_LAST_MODIFY_TIMESTAMP, _last_modify_timestamp, 0);
  }
  /// We like to duplicate namespace here
  /// to avoid re-parsing from the key
  const flatbuffers::String *ns() const {
    return GetPointer<const flatbuffers::String *>(VT_NS);
  }
  flatbuffers::String *mutable_ns() {
    return GetPointer<flatbuffers::String *>(VT_NS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<int8_t> *id() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ID);
  }
  flatbuffers::Vector<int8_t> *mutable_id() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_ID);
  }
  uint32_t partitions() const {
    return GetField<uint32_t>(VT_PARTITIONS, 0);
  }
  bool mutate_partitions(uint32_t _partitions) {
    return SetField<uint32_t>(VT_PARTITIONS, _partitions, 0);
  }
  uint32_t replicas() const {
    return GetField<uint32_t>(VT_REPLICAS, 0);
  }
  bool mutate_replicas(uint32_t _replicas) {
    return SetField<uint32_t>(VT_REPLICAS, _replicas, 0);
  }
  bool compacted() const {
    return GetField<uint8_t>(VT_COMPACTED, 0) != 0;
  }
  bool mutate_compacted(bool _compacted) {
    return SetField<uint8_t>(VT_COMPACTED, static_cast<uint8_t>(_compacted), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VERSION) &&
           VerifyField<int64_t>(verifier, VT_CREATE_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_LAST_MODIFY_TIMESTAMP) &&
           VerifyOffset(verifier, VT_NS) &&
           verifier.VerifyString(ns()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyVector(id()) &&
           VerifyField<uint32_t>(verifier, VT_PARTITIONS) &&
           VerifyField<uint32_t>(verifier, VT_REPLICAS) &&
           VerifyField<uint8_t>(verifier, VT_COMPACTED) &&
           verifier.EndTable();
  }
};

struct TopicMetadataBuilder {
  typedef TopicMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(TopicMetadata::VT_VERSION, version, 0);
  }
  void add_create_timestamp(int64_t create_timestamp) {
    fbb_.AddElement<int64_t>(TopicMetadata::VT_CREATE_TIMESTAMP, create_timestamp, 0);
  }
  void add_last_modify_timestamp(int64_t last_modify_timestamp) {
    fbb_.AddElement<int64_t>(TopicMetadata::VT_LAST_MODIFY_TIMESTAMP, last_modify_timestamp, 0);
  }
  void add_ns(flatbuffers::Offset<flatbuffers::String> ns) {
    fbb_.AddOffset(TopicMetadata::VT_NS, ns);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TopicMetadata::VT_NAME, name);
  }
  void add_id(flatbuffers::Offset<flatbuffers::Vector<int8_t>> id) {
    fbb_.AddOffset(TopicMetadata::VT_ID, id);
  }
  void add_partitions(uint32_t partitions) {
    fbb_.AddElement<uint32_t>(TopicMetadata::VT_PARTITIONS, partitions, 0);
  }
  void add_replicas(uint32_t replicas) {
    fbb_.AddElement<uint32_t>(TopicMetadata::VT_REPLICAS, replicas, 0);
  }
  void add_compacted(bool compacted) {
    fbb_.AddElement<uint8_t>(TopicMetadata::VT_COMPACTED, static_cast<uint8_t>(compacted), 0);
  }
  explicit TopicMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopicMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopicMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopicMetadata> CreateTopicMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    int64_t create_timestamp = 0,
    int64_t last_modify_timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> ns = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> id = 0,
    uint32_t partitions = 0,
    uint32_t replicas = 0,
    bool compacted = false) {
  TopicMetadataBuilder builder_(_fbb);
  builder_.add_last_modify_timestamp(last_modify_timestamp);
  builder_.add_create_timestamp(create_timestamp);
  builder_.add_replicas(replicas);
  builder_.add_partitions(partitions);
  builder_.add_id(id);
  builder_.add_name(name);
  builder_.add_ns(ns);
  builder_.add_version(version);
  builder_.add_compacted(compacted);
  return builder_.Finish();
}

inline flatbuffers::Offset<TopicMetadata> CreateTopicMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t version = 0,
    int64_t create_timestamp = 0,
    int64_t last_modify_timestamp = 0,
    const char *ns = nullptr,
    const char *name = nullptr,
    const std::vector<int8_t> *id = nullptr,
    uint32_t partitions = 0,
    uint32_t replicas = 0,
    bool compacted = false) {
  auto ns__ = ns ? _fbb.CreateString(ns) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto id__ = id ? _fbb.CreateVector<int8_t>(*id) : 0;
  return nlog::CreateTopicMetadata(
      _fbb,
      version,
      create_timestamp,
      last_modify_timestamp,
      ns__,
      name__,
      id__,
      partitions,
      replicas,
      compacted);
}

inline const nlog::TopicMetadata *GetTopicMetadata(const void *buf) {
  return flatbuffers::GetRoot<nlog::TopicMetadata>(buf);
}

inline const nlog::TopicMetadata *GetSizePrefixedTopicMetadata(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<nlog::TopicMetadata>(buf);
}

inline TopicMetadata *GetMutableTopicMetadata(void *buf) {
  return flatbuffers::GetMutableRoot<TopicMetadata>(buf);
}

inline bool VerifyTopicMetadataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<nlog::TopicMetadata>(nullptr);
}

inline bool VerifySizePrefixedTopicMetadataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<nlog::TopicMetadata>(nullptr);
}

inline void FinishTopicMetadataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nlog::TopicMetadata> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTopicMetadataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nlog::TopicMetadata> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace nlog

#endif  // FLATBUFFERS_GENERATED_TOPICMETADATA_NLOG_H_
