// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RECORD_NLOG_H_
#define FLATBUFFERS_GENERATED_RECORD_NLOG_H_

#include "flatbuffers/flatbuffers.h"

namespace nlog {

struct RecordHeader;
struct RecordHeaderBuilder;

struct Record;
struct RecordBuilder;

struct RecordBatch;
struct RecordBatchBuilder;

struct RecordHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordHeaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  flatbuffers::String *mutable_key() {
    return GetPointer<flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<int8_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct RecordHeaderBuilder {
  typedef RecordHeader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(RecordHeader::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(RecordHeader::VT_VALUE, value);
  }
  explicit RecordHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RecordHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecordHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordHeader> CreateRecordHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
  RecordHeaderBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<RecordHeader> CreateRecordHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const std::vector<int8_t> *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  return nlog::CreateRecordHeader(
      _fbb,
      key__,
      value__);
}

struct Record FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_OFFSET_DELTA = 6,
    VT_KEY = 8,
    VT_VALUE = 10,
    VT_HEADERS = 12
  };
  /// event timestamp
  int64_t timestamp() const {
    return GetField<int64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(int64_t _timestamp) {
    return SetField<int64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  /// base_offset + offset_delta is the real offset of this record
  uint16_t offset_delta() const {
    return GetField<uint16_t>(VT_OFFSET_DELTA, 0);
  }
  bool mutate_offset_delta(uint16_t _offset_delta) {
    return SetField<uint16_t>(VT_OFFSET_DELTA, _offset_delta, 0);
  }
  const flatbuffers::Vector<int8_t> *key() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_KEY);
  }
  flatbuffers::Vector<int8_t> *mutable_key() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_KEY);
  }
  const flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  flatbuffers::Vector<int8_t> *mutable_value() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<nlog::RecordHeader>> *headers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<nlog::RecordHeader>> *>(VT_HEADERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<nlog::RecordHeader>> *mutable_headers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<nlog::RecordHeader>> *>(VT_HEADERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<uint16_t>(verifier, VT_OFFSET_DELTA) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyVector(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           VerifyOffset(verifier, VT_HEADERS) &&
           verifier.VerifyVector(headers()) &&
           verifier.VerifyVectorOfTables(headers()) &&
           verifier.EndTable();
  }
};

struct RecordBuilder {
  typedef Record Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int64_t timestamp) {
    fbb_.AddElement<int64_t>(Record::VT_TIMESTAMP, timestamp, 0);
  }
  void add_offset_delta(uint16_t offset_delta) {
    fbb_.AddElement<uint16_t>(Record::VT_OFFSET_DELTA, offset_delta, 0);
  }
  void add_key(flatbuffers::Offset<flatbuffers::Vector<int8_t>> key) {
    fbb_.AddOffset(Record::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(Record::VT_VALUE, value);
  }
  void add_headers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nlog::RecordHeader>>> headers) {
    fbb_.AddOffset(Record::VT_HEADERS, headers);
  }
  explicit RecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Record> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Record>(end);
    return o;
  }
};

inline flatbuffers::Offset<Record> CreateRecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    uint16_t offset_delta = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> key = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nlog::RecordHeader>>> headers = 0) {
  RecordBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_headers(headers);
  builder_.add_value(value);
  builder_.add_key(key);
  builder_.add_offset_delta(offset_delta);
  return builder_.Finish();
}

inline flatbuffers::Offset<Record> CreateRecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t timestamp = 0,
    uint16_t offset_delta = 0,
    const std::vector<int8_t> *key = nullptr,
    const std::vector<int8_t> *value = nullptr,
    const std::vector<flatbuffers::Offset<nlog::RecordHeader>> *headers = nullptr) {
  auto key__ = key ? _fbb.CreateVector<int8_t>(*key) : 0;
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  auto headers__ = headers ? _fbb.CreateVector<flatbuffers::Offset<nlog::RecordHeader>>(*headers) : 0;
  return nlog::CreateRecord(
      _fbb,
      timestamp,
      offset_delta,
      key__,
      value__,
      headers__);
}

/// NativeLog clients always ingest data in RecordBatch and prefixed with a 64bit integer
/// called RecordBatchPrefix which contains some special flags and the length of the RecordBatch
/// NativeLog server validates the prefix and also read the payload according to the length
/// [64bits-prefix][RecordBatch]
struct RecordBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordBatchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CRC = 4,
    VT_FLAGS = 6,
    VT_BASE_OFFSET = 8,
    VT_SHARD_LEADER_EPOCH = 10,
    VT_LAST_OFFSET_DELTA = 12,
    VT_APPEND_TIMESTAMP = 14,
    VT_FIRST_TIMESTAMP = 16,
    VT_MAX_TIMESTAMP = 18,
    VT_PRODUCER_ID = 20,
    VT_PRODUCER_EPOCH = 22,
    VT_BASE_SEQUENCE = 24,
    VT_RECORDS = 26
  };
  /// When server receives a RecordBatch, it first needs validate the CRC
  /// and then setup timestamps etc fields, and re-calculates the CRC before persisting
  /// it to storage
  uint32_t crc() const {
    return GetField<uint32_t>(VT_CRC, 0);
  }
  bool mutate_crc(uint32_t _crc) {
    return SetField<uint32_t>(VT_CRC, _crc, 0);
  }
  /// `flags` bits
  /// [0-3] version
  /// [4-63] reserved
  uint64_t flags() const {
    return GetField<uint64_t>(VT_FLAGS, 0);
  }
  bool mutate_flags(uint64_t _flags) {
    return SetField<uint64_t>(VT_FLAGS, _flags, 0);
  }
  int64_t base_offset() const {
    return GetField<int64_t>(VT_BASE_OFFSET, 0);
  }
  bool mutate_base_offset(int64_t _base_offset) {
    return SetField<int64_t>(VT_BASE_OFFSET, _base_offset, 0);
  }
  int32_t shard_leader_epoch() const {
    return GetField<int32_t>(VT_SHARD_LEADER_EPOCH, 0);
  }
  bool mutate_shard_leader_epoch(int32_t _shard_leader_epoch) {
    return SetField<int32_t>(VT_SHARD_LEADER_EPOCH, _shard_leader_epoch, 0);
  }
  /// Also serves as LastSequenceDelta
  int32_t last_offset_delta() const {
    return GetField<int32_t>(VT_LAST_OFFSET_DELTA, 0);
  }
  bool mutate_last_offset_delta(int32_t _last_offset_delta) {
    return SetField<int32_t>(VT_LAST_OFFSET_DELTA, _last_offset_delta, 0);
  }
  int64_t append_timestamp() const {
    return GetField<int64_t>(VT_APPEND_TIMESTAMP, 0);
  }
  bool mutate_append_timestamp(int64_t _append_timestamp) {
    return SetField<int64_t>(VT_APPEND_TIMESTAMP, _append_timestamp, 0);
  }
  int64_t first_timestamp() const {
    return GetField<int64_t>(VT_FIRST_TIMESTAMP, 0);
  }
  bool mutate_first_timestamp(int64_t _first_timestamp) {
    return SetField<int64_t>(VT_FIRST_TIMESTAMP, _first_timestamp, 0);
  }
  int64_t max_timestamp() const {
    return GetField<int64_t>(VT_MAX_TIMESTAMP, 0);
  }
  bool mutate_max_timestamp(int64_t _max_timestamp) {
    return SetField<int64_t>(VT_MAX_TIMESTAMP, _max_timestamp, 0);
  }
  int64_t producer_id() const {
    return GetField<int64_t>(VT_PRODUCER_ID, 0);
  }
  bool mutate_producer_id(int64_t _producer_id) {
    return SetField<int64_t>(VT_PRODUCER_ID, _producer_id, 0);
  }
  int16_t producer_epoch() const {
    return GetField<int16_t>(VT_PRODUCER_EPOCH, 0);
  }
  bool mutate_producer_epoch(int16_t _producer_epoch) {
    return SetField<int16_t>(VT_PRODUCER_EPOCH, _producer_epoch, 0);
  }
  int32_t base_sequence() const {
    return GetField<int32_t>(VT_BASE_SEQUENCE, 0);
  }
  bool mutate_base_sequence(int32_t _base_sequence) {
    return SetField<int32_t>(VT_BASE_SEQUENCE, _base_sequence, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<nlog::Record>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<nlog::Record>> *>(VT_RECORDS);
  }
  flatbuffers::Vector<flatbuffers::Offset<nlog::Record>> *mutable_records() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<nlog::Record>> *>(VT_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CRC) &&
           VerifyField<uint64_t>(verifier, VT_FLAGS) &&
           VerifyField<int64_t>(verifier, VT_BASE_OFFSET) &&
           VerifyField<int32_t>(verifier, VT_SHARD_LEADER_EPOCH) &&
           VerifyField<int32_t>(verifier, VT_LAST_OFFSET_DELTA) &&
           VerifyField<int64_t>(verifier, VT_APPEND_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_FIRST_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_MAX_TIMESTAMP) &&
           VerifyField<int64_t>(verifier, VT_PRODUCER_ID) &&
           VerifyField<int16_t>(verifier, VT_PRODUCER_EPOCH) &&
           VerifyField<int32_t>(verifier, VT_BASE_SEQUENCE) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
};

struct RecordBatchBuilder {
  typedef RecordBatch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_crc(uint32_t crc) {
    fbb_.AddElement<uint32_t>(RecordBatch::VT_CRC, crc, 0);
  }
  void add_flags(uint64_t flags) {
    fbb_.AddElement<uint64_t>(RecordBatch::VT_FLAGS, flags, 0);
  }
  void add_base_offset(int64_t base_offset) {
    fbb_.AddElement<int64_t>(RecordBatch::VT_BASE_OFFSET, base_offset, 0);
  }
  void add_shard_leader_epoch(int32_t shard_leader_epoch) {
    fbb_.AddElement<int32_t>(RecordBatch::VT_SHARD_LEADER_EPOCH, shard_leader_epoch, 0);
  }
  void add_last_offset_delta(int32_t last_offset_delta) {
    fbb_.AddElement<int32_t>(RecordBatch::VT_LAST_OFFSET_DELTA, last_offset_delta, 0);
  }
  void add_append_timestamp(int64_t append_timestamp) {
    fbb_.AddElement<int64_t>(RecordBatch::VT_APPEND_TIMESTAMP, append_timestamp, 0);
  }
  void add_first_timestamp(int64_t first_timestamp) {
    fbb_.AddElement<int64_t>(RecordBatch::VT_FIRST_TIMESTAMP, first_timestamp, 0);
  }
  void add_max_timestamp(int64_t max_timestamp) {
    fbb_.AddElement<int64_t>(RecordBatch::VT_MAX_TIMESTAMP, max_timestamp, 0);
  }
  void add_producer_id(int64_t producer_id) {
    fbb_.AddElement<int64_t>(RecordBatch::VT_PRODUCER_ID, producer_id, 0);
  }
  void add_producer_epoch(int16_t producer_epoch) {
    fbb_.AddElement<int16_t>(RecordBatch::VT_PRODUCER_EPOCH, producer_epoch, 0);
  }
  void add_base_sequence(int32_t base_sequence) {
    fbb_.AddElement<int32_t>(RecordBatch::VT_BASE_SEQUENCE, base_sequence, 0);
  }
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nlog::Record>>> records) {
    fbb_.AddOffset(RecordBatch::VT_RECORDS, records);
  }
  explicit RecordBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RecordBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RecordBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<RecordBatch> CreateRecordBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t crc = 0,
    uint64_t flags = 0,
    int64_t base_offset = 0,
    int32_t shard_leader_epoch = 0,
    int32_t last_offset_delta = 0,
    int64_t append_timestamp = 0,
    int64_t first_timestamp = 0,
    int64_t max_timestamp = 0,
    int64_t producer_id = 0,
    int16_t producer_epoch = 0,
    int32_t base_sequence = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<nlog::Record>>> records = 0) {
  RecordBatchBuilder builder_(_fbb);
  builder_.add_producer_id(producer_id);
  builder_.add_max_timestamp(max_timestamp);
  builder_.add_first_timestamp(first_timestamp);
  builder_.add_append_timestamp(append_timestamp);
  builder_.add_base_offset(base_offset);
  builder_.add_flags(flags);
  builder_.add_records(records);
  builder_.add_base_sequence(base_sequence);
  builder_.add_last_offset_delta(last_offset_delta);
  builder_.add_shard_leader_epoch(shard_leader_epoch);
  builder_.add_crc(crc);
  builder_.add_producer_epoch(producer_epoch);
  return builder_.Finish();
}

inline flatbuffers::Offset<RecordBatch> CreateRecordBatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t crc = 0,
    uint64_t flags = 0,
    int64_t base_offset = 0,
    int32_t shard_leader_epoch = 0,
    int32_t last_offset_delta = 0,
    int64_t append_timestamp = 0,
    int64_t first_timestamp = 0,
    int64_t max_timestamp = 0,
    int64_t producer_id = 0,
    int16_t producer_epoch = 0,
    int32_t base_sequence = 0,
    const std::vector<flatbuffers::Offset<nlog::Record>> *records = nullptr) {
  auto records__ = records ? _fbb.CreateVector<flatbuffers::Offset<nlog::Record>>(*records) : 0;
  return nlog::CreateRecordBatch(
      _fbb,
      crc,
      flags,
      base_offset,
      shard_leader_epoch,
      last_offset_delta,
      append_timestamp,
      first_timestamp,
      max_timestamp,
      producer_id,
      producer_epoch,
      base_sequence,
      records__);
}

inline const nlog::RecordBatch *GetRecordBatch(const void *buf) {
  return flatbuffers::GetRoot<nlog::RecordBatch>(buf);
}

inline const nlog::RecordBatch *GetSizePrefixedRecordBatch(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<nlog::RecordBatch>(buf);
}

inline RecordBatch *GetMutableRecordBatch(void *buf) {
  return flatbuffers::GetMutableRoot<RecordBatch>(buf);
}

inline bool VerifyRecordBatchBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<nlog::RecordBatch>(nullptr);
}

inline bool VerifySizePrefixedRecordBatchBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<nlog::RecordBatch>(nullptr);
}

inline void FinishRecordBatchBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nlog::RecordBatch> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRecordBatchBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<nlog::RecordBatch> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace nlog

#endif  // FLATBUFFERS_GENERATED_RECORD_NLOG_H_
